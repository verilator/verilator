: # -*-Mode: perl;-*- use perl, wherever it is
eval 'exec perl -wS $0 ${1+"$@"}'
  if 0;
# $Id$
######################################################################
#
# Copyright 2003-2007 by Wilson Snyder. This program is free software; you can
# redistribute it and/or modify it under the terms of either the GNU
# General Public License or the Perl Artistic License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
######################################################################

require 5.006_001;
use warnings;
BEGIN {
    if (my $Project=($ENV{DIRPROJECT}||$ENV{PROJECT})) {
	# Magic to allow author testing of perl packages in local directory
	require "$Project/hw/utils/perltools/boot.pl";
    }
}

use File::Path;
use File::Basename;
use Getopt::Long;
use FindBin qw($RealBin $RealScript);
use IO::File;
use Pod::Usage;
use Config;
use Cwd qw(abs_path getcwd);

use strict;
use vars qw ($Debug %Vars $Opt $Opt_Make_Dir $Opt_Sp @Opt_Verilator_Sw
	     $Opt_Trace
	     %Modules
	     );

#######################################################################
# Global constants -- Configuration info

# Where to find real executables
# We could find it by using $RealBin, but we require this path
# so that when the user runs make, they will have it and not get strange error.
$ENV{VERILATOR_ROOT} or die "%Error: verilator: VERILATOR_ROOT needs to be in environment\n";
print "export VERILATOR_ROOT=$ENV{VERILATOR_ROOT}\n" if $Debug;

# Read by verilator for populating makefile
if (!defined $ENV{SYSTEMC_ARCH}) {
    $ENV{SYSTEMC_ARCH} ||= (($Config{osname} =~ /solaris/i && "gccsparcOS5")
			    || ($Config{osname} =~ /cygwin/i && "cygwin")
			    || "linux");
    print "export SYSTEMC_ARCH=$ENV{SYSTEMC_ARCH}\n" if $Debug;
}

#######################################################################
#######################################################################
# main

autoflush STDOUT 1;
autoflush STDERR 1;

$Debug = 0;
my $opt_gdb;
$Opt_Sp = undef;

# No arguments can't do anything useful.  Give help
if ($#ARGV < 0) {
    pod2usage(-exitstatus=>2, -verbose=>0);
}

# Insert debugging options up front
push @ARGV, (split ' ',$ENV{VERILATOR_TEST_FLAGS}||"");

# We sneak a look at the flags so we can do some pre-environment checks
# All flags will hit verilator...
@Opt_Verilator_Sw = @ARGV;

Getopt::Long::config ("no_auto_abbrev","pass_through");
if (! GetOptions (
		  # Major operating modes
		  "help"	=> \&usage,
		  "debug:s"	=> \&debug,
		  "version!"	=> \&version,
		  # Switches
		  "gdb=s"	=> \$opt_gdb,	# Undocumented debugging
		  "trace!"	=> \$Opt_Trace,
		  "sp!"		=> sub {$Opt_Sp = 'sp';},
		  "sc!"		=> sub {$Opt_Sp = 'sc';},
		  "cc!"		=> sub {$Opt_Sp = 0;},
		  #"ignc!"	=> ...,		# Undocumented debugging, disable $c but don't complain
		  # Additional parameters
		  "<>"		=> sub {},	# Ignored
		  )) {
    pod2usage(-exitstatus=>2, -verbose=>0);
}

# Check configuration
if ($Opt_Sp) {
    (defined $ENV{SYSTEMC}) or die "%Error: verilator: Need \$SYSTEMC in environment\nProbably System-C isn't installed, see http://www.systemc.org\n";
}
if ($Opt_Sp eq 'sp' || $Opt_Trace) {
    if (!defined $ENV{SYSTEMPERL}) {
	my $try = "$ENV{W}/hw/utils/perltools/SystemC";
	$ENV{SYSTEMPERL} = $try if -d $try;
    }
    (defined $ENV{SYSTEMPERL}) or die "%Error: verilator: Need \$SYSTEMPERL in environment for --sp or --trace\nProbably System-Perl isn't installed, see http://www.veripool.com/systemperl.html\n";
    (-d "$ENV{SYSTEMPERL}/src") or die "%Error: verilator: \$SYSTEMPERL environment var doesn't seem to point to System-Perl kit\n";
}

# Determine runtime flags
my $vcmd =(($opt_gdb?"$opt_gdb ":"")
	   .verilator_bin()
	   ." ".join(' ',@Opt_Verilator_Sw)
	   );

# Run verilator
run ($vcmd);

#----------------------------------------------------------------------

sub usage {
    bin_version();
    print '$Revision$$Date$ ', "\n";
    pod2usage(-exitstatus=>2, -verbose=>2);
}

sub debug {
    shift;
    my $level = shift;
    $Debug = $level||3;
}

sub version {
    bin_version();
    exit (0);
}

sub bin_version {
    ($ENV{VERILATOR_ROOT}) or print "%Warning: Unknown rev: VERILATOR_ROOT undefined\n";
    run (verilator_bin()." --version");
}

#######################################################################
#######################################################################
# Builds

sub verilator_bin {
    my $bin = "$ENV{VERILATOR_ROOT}/".($ENV{VERILATOR_BIN}||"verilator_bin");
    if ($Debug && -x "${bin}_dbg") { $bin = "${bin}_dbg"; }
    return $bin;
}

#######################################################################
#######################################################################
# Utilities

sub run {
    # Run command, check errors
    my $command = shift;
    print "\t$command\n" if $Debug>=3;
    system($command);
    my $status = $?;
    if ($status) {
	if ($Debug) {  # For easy rerunning
	    warn "%Error: export VERILATOR_ROOT=$ENV{VERILATOR_ROOT}\n";
	    warn "%Error: $command\n";
	}
	die "%Error: Command Failed $command\n";
    }
}

#######################################################################
#######################################################################
package main;
__END__

=pod

=head1 NAME

Verilator - Convert Verilog code to C++/SystemC

=head1 SYNOPSIS

    verilator --help
    verilator --version
    verilator --cc [options] [top_level.v] [opt_c_files.cpp/c/cc]
    verilator --sc [options] [top_level.v] [opt_c_files.cpp/c/cc]
    verilator --sp [options] [top_level.v] [opt_c_files.cpp/c/cc]

=head1 DESCRIPTION

Verilator converts synthesizable (not behavioral) Verilog code, plus some
Synthesis, SystemVerilog and Sugar/PSL assertions, into C++, SystemC or
SystemPerl code.  It is not a complete simulator, just a compiler.

Verilator is invoked with parameters similar to GCC, Cadence
Verilog-XL/NC-Verilog, or Synopsys's VCS.  It reads the specified Verilog
code, lints it, and optionally adds coverage and waveform tracing code.
For C++ and SystemC formats, it outputs .cpp and .h files.  For SystemPerl
format, it outputs .sp files for the SystemPerl preprocessor, which greatly
simplifies writing SystemC code and is available at
L<http://www.veripool.com>.

The files created by Verilator are then compiled with C++.  The user writes
a little C++ wrapper file, which instantiates the top level module, and
passes this filename on the command line.  These C files are compiled in
C++, and linked with the Verilated files.

The resulting executable will perform the actual simulation.

=head1 ARGUMENTS

=over 4

=item {file.v}

Specifies the Verilog file containing the top module to be Verilated.

=item {file.c/cc/cpp}

Specifies optional C++ files to be linked in with the Verilog code.  If any
C++ files are specified in this way, Verilator will include a make rule
that generates a I<module> executable.  Without any C++ files, Verilator
will stop at the I<module>__ALL.a library, and presume you'll continue
linking with make rules you write yourself.

=item --assert

Enable all assertions, includes enabling the --psl flag.  (If psl is not
desired, but other assertions are, use --assert --nopsl.)

=item --bin I<filename>

Rarely needed.  Override the default filename for Verilator itself.  When a
dependency (.d) file is created, this filename will become a source
dependency, such that a change in this binary will have make rebuild the
output files.

=item --cc

Specifies C++ without SystemC output mode; see also --sc and --sp.

=item --coverage

Enables all forms of coverage, alias for --coverage-line, --coverage-user

=item --coverage-line

Specifies basic block line coverage analysis code should be inserted.

Coverage analysis adds statements at each code flow change point, which are
the branches of IF and CASE statements, a super-set of normal Verilog Line
Coverage.  At each such branch a unique counter is incremented.  At the end
of a test, the counters along with the filename and line number
corresponding to each counter are written into logs/coverage.pl.

After running multiple tests, the vcoverage utility (from the SystemPerl
package) is executed.  Vcoverage reads the logs/coverage.pl file(s), and
creates an annotated source code listing showing code coverage details.

Verilator automatically disables coverage of branches that have a $stop in
them, as it is assumed $stop branches contain an error check that should
not occur.  A /*verilator coverage_block_off*/ comment will perform a
similar function on any code in that block or below.

Note Verilator may over-count combinatorial (non-clocked) blocks when those
blocks receive signals which have had the UNOPTFLAT warning disabled; for
most accurate results do not disable this warning when using coverage.

For an example, after running 'make test' in the Verilator distribution,
see the test_sp/logs/coverage_source directory.  Grep for lines starting
with '%' to see what lines Verilator believes need more coverage.

=item --coverage-user

Enables user inserted functional coverage.  Currently, all functional
coverage points are specified using PSL which must be separately enabled
with --psl.

For example, the following PSL statement will add a coverage point, with
the comment "DefaultClock":

   // psl default clock = posedge clk;
   // psl cover {cyc==9} report "DefaultClock,expect=1";

=item --debug

Select the debug built image of Verilator (if available), and enable more
internal assertions, debugging messages, and intermediate form dump files.

=item --debug-check

Rarely needed.  Enable internal debugging assertion checks, without
changing debug verbosity.  Enabled automatically when --debug specified.

=item -E

Preprocess the source code, but do not compile, as with 'gcc -E'.  Output
is written to standard out.  Beware of enabling debugging messages, as they
will also go to standard out.

=item --exe

Generate a executable.  You will also need to pass additional .cpp files on
the command line that implement the main loop for your simulation.

=item --help

Displays this message and program version and exits.

=item --inhibit-sim

Rarely needed.  Create a "inhibitSim(bool)" function to enable and disable
evaluation.  This allows a upper level testbench to disable modules that
are not important in a given simulation, without needing to recompile or
change the SystemC modules instantiated.

=item --inline-mult I<value>

Tune the inlining of modules.  The default value of 2000 specifies that up
to 2000 new operations may be added to the model by inlining, if more then
this number of operations would result, the module is not inlined.  Larger
values, or -1 to inline everything, will lead to longer compile times, but
potentially faster runtimes.  This setting is ignored for very small
modules; they will always be inlined, if allowed.

=item --MMD

Enable creation of .d dependency files, used for make dependency detection,
similar to gcc -MMD option.  On by default, use --no-MMD to disable.

=item --MP

When creating .d dependency files with --MMD, make phony targets.  Similar
to gcc -MP option.

=item --Mdir I<directory>

Specifies the name of the Make object directory.  All generated files will
be placed in this directory.

=item --mod-prefix I<topname>

Specifies the name to prepend to all lower level classes.  Defaults to
the same as --prefix.

=item --no-skip-identical

Rarely needed.  Disables skipping execution of Verilator if all source
files are identical, and all output files exist with newer dates.

=item -O0

Disables optimization of the model.

=item -O3

Enables slow optimizations.  This may reduce simulation runtimes at the
cost of compile time.  This currently sets --inline-mult -1.

=item -OI<optimization-letter>

Rarely needed.  Enables or disables a specific optimizations, with the
optimization selected based on the letter passed.  A lowercase letter
disables an optimization, an upper case letter enables it.  This is
intended for debugging use only; see the source code for version-dependent
mappings of optimizations to -O letters.

=item --output-split I<bytes>

Enables splitting the output .cpp/.sp files into multiple outputs.  When a
C++ file exceeds the specified number of operations, a new file will be
created.  In addition, any slow routines will be placed into __Slow files.
This accelerates compilation by as optimization can be disabled on the slow
routines, and the remaining files can be compiled on parallel machines.
Using --output-split should have only a trivial impact on performance.
With GCC 3.3 on a 2GHz Opteron, --output-split 20000 will result in
splitting into approximately one-minute-compile chunks.

=item --output-split-cfuncs I<statements>

Enables splitting functions in the output .cpp/.sp files into multiple
functions.  When a generated function exceeds the specified number of
operations, a new function will be created.  With --output-split, this will
enable GCC to compile faster, at a small loss in performance that increases
with smaller statement values.

=item --pins64

Specifies SystemC outputs of 33-64 bits wide should use uint64_t instead of
the backward-compatible default of sc_bv's.

=item --prefix I<topname>

Specifies the name of the top level class.  Defaults to the name of the top
level Verilog module.

=item --profile-cfuncs

Modify the created C++ functions to support profiling.  The functions will
be minimized to contain one "basic" statement, generally a single always
block or wire statement.  (Note this will slow down the executable by ~5%.)
Furthermore, the function name will be suffixed with the basename of the
Verilog module and line number the statement came from.  This allows gprof
or oprofile reports to be correlated with the original Verilog source
statements.

=item --private

Opposite of --public.  Is the default; this option exists for backwards
compatibility.

=item --psl

Enable PSL parsing.  Without this switch, PSL meta-comments are ignored.
See the --assert flag to enable all assertions, and --coverage-user to
enable functional coverage.

=item --public

This is only for historical debug use.  Using it may result in
mis-simulation of generated clocks.

Declares all signals and modules public.  This will turn off signal
optimizations as if all signals had a /*verilator public*/ comments and
inlining.  This will also turn off inlining as if all modules had a
/*verilator public_module*/, unless the module specifically enabled it with
/*verilator inline_module*/.

=item --sc

Specifies SystemC output mode; see also --cc and -sp.

=item --sp

Specifies SystemPerl output mode; see also --cc and -sc.

=item --stats

Creates a dump file with statistics on the design in {prefix}__stats.txt.

=item --trace

Adds waveform tracing code to the model.  Having tracing compiled in may
result in some small performance losses, even when waveforms are not turned
on during model execution.

=item --trace-depth I<levels>

Specify the number of levels deep to enable tracing, for example
--trace-level 1 to only see the top level's signals.  Defaults to the
entire model.  Using a small number will decrease visibility, but greatly
improve runtime and trace file size.

=item --underline-zero

Rarely needed.  Signals starting with a underline should be initialized to
zero, as was done in Verilator 2.  Default is for all signals including
those with underlines being randomized.  This option may be depreciated in
future versions.

=item -Werror-I<message>

Convert the specified warning message into a error message.  This is
generally to discourage users from violating important site-wide rules, for
example C<-Werror-NOUNOPTFLAT>.

=item -Wno-I<message>

Disable the specified warning message.

=item -x-assign 0

=item -x-assign 1

=item -x-assign unique  (default)

Controls the two-state value that is replaced when an assignment to X is
encountered.  -x-assign=0 converts all Xs to 0s, this is the fastest.
-x-assign=1 converts all Xs to 1s, this is nearly as fast, but more likely
to find reset bugs as active high logic will fire.  The default,
-x-assign=func will call a function to determine the value, this allows
randomization of all Xs and is the slowest, but safest.

=back

=head1 VERILOG ARGUMENTS

The following arguments are compatible with GCC, VCS and most Verilog
programs.

=over 4

=item +define+I<var>+I<value>

=item -DI<var>=I<value>

Defines the given preprocessor symbol.

=item -f I<file>

Read the specified file, and act as if all text inside it was
specified as command line parameters.

=item +incdir+I<dir>

=item -II<dir>

=item -y I<dir>

Add the directory to the list of directories that should be searched
for include directories or libraries.

=item +libext+I<ext>+I<ext>...

Specify the extensions that should be used for finding modules.  If for
example module I<x> is referenced, look in I<x>.I<ext>.

=item -UI<var>

Undefines the given preprocessor symbol.

=item -v I<filename>

Read the filename as a Verilog library.  Any modules in the file may be
used to resolve cell instantiations in the top level module, else ignored.

=back

=head1 EXAMPLE C++ EXECUTION

We'll compile this example into C++.

    mkdir test_our
    cd test_our

    cat <<EOF >our.v
      module our;
         initial begin \$display("Hello World"); \$finish; end
      endmodule
    EOF

    cat <<EOF >sim_main.cpp
      #include "Vour.h"
      #include "verilated.h"
      int main(int argc, char **argv, char **env) {
          Vour* top = new Vour;
          while (!Verilated::gotFinish()) { top->eval(); }
      }
    EOF

Now we run Verilator on our little example.

    export VERILATOR_ROOT=/path/to/where/verilator/was/installed
    $VERILATOR_ROOT/bin/verilator --cc our.v --exe sim_main.cpp

We can see the source code under the "obj_dir" directory.  See the FILES
section below for descriptions of some of the files that were created.

    ls -l obj_dir

We then can compile it

    cd obj_dir
    make -f Vour.mk Vour

(Verilator included a default compile rule and link rule, since we used
--exe and passed a .cpp file on the Verilator command line.  You can also
write your own compile rules, as we'll show in the SYSTEMC section.)

And now we run it

    cd ..
    obj_dir/Vour

And we get as output

    Hello World
    - our.v:2: Verilog $finish

Really, you're better off writing a Makefile to do all this for you.  Then,
when your source changes it will automatically run all of these steps.  See
the test_c directory in the distribution for an example.

=head1 EXAMPLE SYSTEMC EXECUTION

This is an example similar to the above, but using SystemPerl.

    mkdir test_our_sc
    cd test_our_sc

    cat <<EOF >our.v
      module our (clk);
         input clk;  // Clock is required to get initial activation
         always @ (posedge clk)
            begin \$display("Hello World"); \$finish; end
      endmodule
    EOF

    cat <<EOF >sc_main.cpp
      #include "Vour.h"
      #include "systemperl.h"
      int sc_main(int argc, char **argv) {
          sc_clock clk ("clk",10, 0.5, 3, true);
          Vour* top;
          SP_CELL (top, Vour);
          SP_PIN  (top, clk, clk);
          while (!Verilated::gotFinish()) { sc_start(1); }
      }
    EOF

Now we run Verilator on our little example.

    export VERILATOR_ROOT=/path/to/where/verilator/was/installed
    $VERILATOR_ROOT/bin/verilator --sp our.v

Then we convert the SystemPerl output to SystemC.

    cd obj_dir
    export SYSTEMPERL=/path/to/where/systemperl/kit/came/from
    $SYSTEMPERL/sp_preproc --preproc *.sp

(You can also skip the above sp_preproc by getting pure SystemC from
Verilator by replacing the verilator --sp flag in the previous step with
-sc.)

We then can compile it

    make -f Vour.mk Vour__ALL.a
    make -f Vour.mk ../sc_main.o
    make -f Vour.mk verilated.o

And link with SystemC.  Note your path to the libraries may vary,
depending on the operating system.

    export SYSTEMC=/path/to/where/systemc/was/built/or/installed
    g++ -L$SYSTEMC/lib-linux ../sc_main.o Vour__ALL*.o verilated.o \
              -o Vour -lsystemc

And now we run it

    cd ..
    obj_dir/Vour

And we get the same output as the C++ example:

    Hello World
    - our.v:2: Verilog $finish

Really, you're better off using a Makefile to do all this for you.  Then,
when your source changes it will automatically run all of these steps.  See
the test_sp directory in the distribution for an example.

=head1 BENCHMARKING & OPTIMIZATION

For best performance, run Verilator with the "-O3 -x-assign=0 --noassert"
flags.  The -O3 flag will require longer compile times, and -x-assign=0 may
increase the risk of reset bugs in trade for performance; see the above
documentation for these flags.

Minor Verilog code changes can also give big wins.  You should not have any
UNOPTFLAT warnings from Verilator.  Fixing these warnings can result in
huge improvements; one user fixed their one UNOPTFLAT warning by making a
simple change to a clock latch used to gate clocks and gained a 60%
performance improvement.

Beyond that, the performance of a Verilated model depends mostly on your
C++ compiler and size of your CPU's caches.

By default, the lib/verilated.mk file has optimization turned off.  This is
for the benefit of new users, as it improves compile times at the cost of
runtimes.  To add optimization as the default, set one of three variables,
OPT, OPT_FAST, or OPT_SLOW in lib/verilated.mk. Or, just for one run, pass
them on the command line to make:

    make OPT_FAST="-O2" -f Vour.mk Vour__ALL.a

OPT_FAST specifies optimizations for those programs that are part of the
fast path, mostly code that is executed every cycle.  OPT_SLOW specifies
optimizations for slow-path files (plus tracing), which execute only
rarely, yet take a long time to compile with optimization on.  OPT
specifies overall optimization and affects all compiles, including those
OPT_FAST and OPT_SLOW affect.  For best results, use OPT="-O2".  Nearly the
same results can be had with much better compile times with OPT_FAST="-O1
-fstrict-aliasing".  Unfortunately, using the optimizer with SystemC files
can result in compiles taking several minutes.  (The SystemC libraries have
many little inlined functions that drive the compiler nuts.)

For best results, use GCC 3.3 or newer.  GCC 3.2 and earlier have
optimization bugs around pointer aliasing detection, which can result in 2x
performance losses.

If you will be running many simulations on a single compile, investigate
feedback driven compilation.  With GCC, using -fprofile-arcs, then
-fbranch-probabilities will yield another 15% or so.

You may uncover further tuning possibilities by profiling the Verilog code.
Use Verilator's --profile-cfuncs, then GCC's -g -pg.  You can then run
either oprofile or gprof to see where in the C++ code, and by looking at
the mangled function name where in the Verilog code most of the time is
being spent.

When done, please let the author know the results.  I like to keep tabs on
how Verilator compares, and may be able to suggest additional improvements.

=head1 FILES

Verilator creates the following files:

    {prefix}.mk				// Make include file for compiling
    {prefix}_classes.mk			// Make include file with class names

For -cc and -sc mode, it also creates:

    {prefix}.cpp			// Top level C++ file
    {prefix}.h				// Top level header
    {prefix}{each_verilog_module}.cpp	// Lower level internal C++ files
    {prefix}{each_verilog_module}.h	// Lower level internal header files

For -sp mode, it also creates:

    {prefix}.sp				// Top level SystemC file
    {prefix}{each_verilog_module}.sp	// Lower level internal SC files

In certain optimization modes, it also creates:

    {prefix}__Slow.cpp			// Constructors and infrequent routines
    {prefix}__Syms.cpp			// Global symbol table C++
    {prefix}__Syms.h			// Global symbol table header
    {prefix}__Trace.cpp			// Wave file generation code (--trace)
    {prefix}__stats.txt			// Statistics (--stats)

It also creates internal files that can be mostly ignored:

    {each_verilog_module}.vpp		// Post-processed verilog (--debug)
    {prefix}.flags_vbin			// Verilator dependencies
    {prefix}.flags_vpp			// Pre-processor dependencies
    {prefix}{misc}.d			// Make dependencies (-MMD)
    {prefix}{misc}.dot			// Debugging graph files (--debug)
    {prefix}{misc}.tree			// Debugging files (--debug)

After running Make, the compiler will produce the following:
    {prefix}				// Final executable (w/--exe argument)
    {prefix}__ALL.a			// Library of all Verilated objects
    {prefix}{misc}.o			// Intermediate objects

=head1 ENVIRONMENT

=over 4

=item SYSTEMC

Required for SystemC output mode.  If set, specifies the directory
containing the SystemC distribution.  This is used to find the SystemC
include files.

=item SYSTEMC_ARCH

Specifies the architecture name used by the SystemC kit.  This is the part
after the dash in the lib-{...} directory name created by a 'make' in the
SystemC distribution.  If not set, Verilator will try to intuit the proper
setting.

=item SYSTEMC_CXX_FLAGS

Specifies additional flags that are required to be passed to GCC when
building the SystemC model.

=item SYSTEMPERL

Specifies the directory containing the Verilog-Perl distribution kit.  This
is used to find the Verilog-Perl library and include files.

=item VCS_HOME

If set, specifies the directory containing the Synopsys VCS distribution.
When set, a 'make test' in the Verilator distribution will also run VCS
baseline regression tests.

=item VERILATOR_BIN

If set, specifies an alternative name of the Verilator binary.  May be used
for debugging and selecting between multiple operating system builds.

=item VERILATOR_ROOT

Specifies the directory containing the distribution kit.  This is used to
find the executable, Perl library, and include files.

=back

=head1 CONNECTING TO C++

Verilator creates a .h and .cpp file for the top level module and all
modules under it.  See the test_c directory in the kit for an example.

After the modules are completed, there will be a I<module>.mk file that may
be used with Make to produce a I<module>__ALL.a file with all required
objects in it.  This is then linked with the user's top level to create the
simulation executable.

The user must write the top level of the simulation.  Here's a simple
example:

	#include <verilated.h>		// Defines common routines
	#include "Vtop.h"		// From Verilating "top.v"

	Vtop *top;			// Instantiation of module

	unsigned int main_time = 0;	// Current simulation time

	double sc_time_stamp () {	// Called by $time in Verilog
    	    return main_time;
	}

	int main() {
	    top = new Vtop;		// Create instance

	    top->reset_l = 0;		// Set some inputs

	    while (!Verilated::gotFinish()) {
		if (main_time > 10) {
		    top->reset_l = 1;	// Deassert reset
		}
		if ((main_time % 10) == 1) {
		    top->clk = 1;	// Toggle clock
		}
		if ((main_time % 10) == 6) {
		    top->clk = 0;
		}
		top->eval();		// Evaluate model
		cout << top->out << endl;	// Read a output
		main_time++;		// Time passes...
	    }

	    top->final();		// Done simulating
	    //	  // (Though this example doesn't get here)
	}

Note signals are read and written as member variables of the lower module.
You call the eval() method to evaluate the model.  When the simulation is
complete call the final() method to wrap up any SystemVerilog final blocks,
and complete any assertions.

=head1 CONNECTING TO SYSTEMC

Verilator will convert the top level module to a SC_MODULE.  This module
will plug directly into a SystemC netlist.

The SC_MODULE gets the same pinout as the Verilog module, with the
following type conversions: Pins of a single bit become bool, unless they
are marked with `systemc_clock, in which case they become sc_clock's (for
SystemC 1.2, not needed in SystemC 2.0).  Pins 2-32 bits wide become
uint32_t's.  Pins 33-64 bits wide become sc_bv's or uint64_t's depending on
the -pins64 switch.  Wider pins become sc_bv's.

Lower modules are not pure SystemC code.  This is a feature, as using the
SystemC pin interconnect scheme everywhere would reduce performance by an
order of magnitude.

=head1 CROSS COMPILATION

Verilator supports cross-compiling Verilated code.  This is generally used
to run Verilator on a Linux system and produce C++ code that is then compiled
on Windows.

Cross compilation involves up to three different OSes.  The build system is
where you configured and compiled Verilator, the host system where you run
Verilator, and the target system where you compile the Verilated code and
run the simulation.

Currently, Verilator requires the build and host system type to be the
same, though the target system type may be different.  To support this,
./configure and make Verilator on the build system.  Then, run Verilator on
the host system.  Finally, the output of Verilator may be compiled on the
different target system.

To support this, none of the files that Verilator produces will reference
any configure generated build-system specific files, such as config.h
(which is renamed in Verilator to config_build.h to reduce confusion.)  The
disadvantage of this approach is that include/verilatedos.h must
self-detect the requirements of the target system, rather then using
configure.

The target system may also require edits to the Makefiles, the simple
Makefiles produced by Verilator presume the target system is the same type
as the build system.

=head1 VERILOG 2001 (IEEE 1364-2001) SUPPORT

Verilator supports almost all Verilog 2001 language features.  This
includes signed numbers, "always @*", comma separated sensitivity lists,
generate statements, multidimensional arrays, localparam, and C-style
declarations inside port lists.

=head1 VERILOG 2005 (IEEE 1364-2005) SUPPORT

Verilator supports the `begin_keywords and `end_keywords compiler
directives.

Verilator partially supports the uwire keyword.

=head1 SYSTEMVERILOG (IEEE 1800-2005) SUPPORT

Verilator currently has very minimal support for SystemVerilog. As
SystemVerilog features enter common usage they will be added.  Contact the
author if a feature you need is missing.

Verilator implements the full SystemVerilog 1800-2005 preprocessor subset,
including function call-like preprocessor defines.

Verilator supports $bits, $countones, $error, $fatal, $info, $isunknown,
$onehot, $onehot0, $warning, always_comb, always_ff, always_latch,
do-while, and final.  It also supports .name and .* interconnection.

Verilator partially supports assert.

=head1 SUGAR/PSL SUPPORT

Most future work is being directed towards improving SystemVerilog
assertions instead of PSL.  If you are using these PSL features, please
contact the author as they may be depreciated in future versions.

With the --assert switch, Verilator enables support of the Property
Specification Language (PSL), specifically the simple PSL subset without
time-branching primitives.  Verilator currently only converts PSL
assertions to simple "if (...) error" statements, and coverage statements
to increment the line counters described in the coverage section.

Verilator implements these keywords: assert, assume (same as assert),
default (for clocking), countones, cover, isunknown, onehot, onehot0,
report, true.

Verilator implements these operators: -> (logical if).

Verilator does not support SEREs yet.  All assertion and coverage
statements must be simple expressions that complete in one cycle.  PSL
vmode/vprop/vunits are not supported.  PSL statements must be in the module
they reference, at the module level where you would put an
initial... statement.

Verilator only supports (posedge CLK) or (negedge CLK), where CLK is the
name of a one bit signal.  You may not use arbitrary expressions as
assertion clocks.

=head1 SYNTHESIS DIRECTIVE ASSERTION SUPPORT

With the --assert switch, Verilator reads any "//synopsys full_case" or "//
synopsys parallel_case" directives.  The same applies to any "//cadence" or
"// ambit synthesis" directives of the same form.

When these synthesis directives are discovered, Verilator will either
formally prove the directive to be true, or failing that, will insert the
appropriate code to detect failing cases at runtime and print an "Assertion
failed" error message.

=head1 LANGUAGE EXTENSIONS

The following additional constructs are the extensions Verilator supports
on top of standard Verilog code.  Using these features outside of comments
or `ifdef's may break other tools.

=over 4

=item `__FILE__

The __FILE__ define expands to the current filename, like C++'s __FILE__.

=item `__LINE__

The __LINE__ define expands to the current line number, like C++'s __LINE__.

=item `error I<string>

This will report an error when encountered, like C++'s #error.

=item _(I<expr>)

A underline followed by an expression in parenthesis returns a Verilog
expression.  This is different from normal parenthesis in special contexts,
such as PSL expressions, and can be used to embed bit concatenation ({})
inside of PSL statements.

=item $c(I<string>, ...);

The string will be embedded directly in the output C++ code at the point
where the surrounding Verilog code is compiled.  It may either be a
standalone statement (with a trailing ; in the string), or a function that
returns up to a 32-bit number (without a trailing ;). This can be used to
call C++ functions from your Verilog code.

String arguments will be put directly into the output C++ code.  Expression
arguments will have the code to evaluate the expression inserted.  Thus to
call a C++ function, $c("func(",a,")") will result in 'func(a)' in the
output C++ code.  For input arguments, rather then hard-coding variable
names in the string $c("func(a)"), instead pass the variable as an
expression $c("func(",a,")").  This will allow the call to work inside
Verilog functions where the variable is flattened out, and also enable
other optimizations.

If you will be reading or writing any Verilog variables inside the C++
functions, the Verilog signals must be declared with /*verilator public*/.

You may also append a arbitrary number to $c, generally the width of the
output.  [signal_32_bits = $c32("...");] This allows for compatibility with
other simulators which require a differently named PLI function name for
each different output width.

=item $display, $write, $fdisplay, $fwrite

Format arguments may use C fprintf sizes after the % escape.  Per the
Verilog standard, %x prints a number with the natural width, %0x prints a
number with minimum width, however %5x prints 5 digits per the C standard
(it's unspecified in Verilog).

=item `coverage_block_off

Specifies the entire begin/end block should be ignored for coverage analysis.
Same as /* verilator coverage_block_off */.

=item `systemc_header

Take remaining text up to the next `verilog or `systemc_... mode switch and
place it verbatim into the output .h file's header.  Despite the name of this
macro, this also works in pure C++ code.

=item `systemc_ctor

Take remaining text up to the next `verilog or `systemc_... mode switch and
place it verbatim into the C++ class constructor.  Despite the name of this
macro, this also works in pure C++ code.

=item `systemc_dtor

Take remaining text up to the next `verilog or `systemc_... mode switch and
place it verbatim into the C++ class destructor.  Despite the name of this
macro, this also works in pure C++ code.

=item `systemc_interface

Take remaining text up to the next `verilog or `systemc_... mode switch and
place it verbatim into the C++ class interface.  Despite the name of this
macro, this also works in pure C++ code.

=item `systemc_imp_header

Take remaining text up to the next `verilog or `systemc_... mode switch and
place it verbatim into the header of all files for this C++ class
implementation.  Despite the name of this macro, this also works in pure
C++ code.

=item `systemc_implementation

Take remaining text up to the next `verilog or `systemc_... mode switch and
place it verbatim into a single file of the C++ class implementation.
Despite the name of this macro, this also works in pure C++ code.

If you will be reading or writing any Verilog variables in the C++
functions, the Verilog signals must be declared with /*verilator public*/.
See also the public task feature; writing a accessor may result in cleaner
code.

=item `verilator

=item `verilator3

The verilator and verilator3 defines are set by default so you may `ifdef
around compiler specific constructs.

=item `verilog

Switch back to processing Verilog code, after a `systemc_... mode switch.

=item /*verilator clock_enable*/

Experimental use only.  Used after a signal declaration to indicate the
signal is used to gate a clock, and the user takes responsibility for
insuring there are no races related to it.  (Typically by adding a latch,
and running static timing analysis.) This will cause the clock gate to be
ignored in the scheduling algorithm, improving performance.

=item /*verilator coverage_block_off*/

Specifies the entire begin/end block should be ignored for coverage analysis.

=item /*verilator inline_module*/

Specifies the module the comment appears in may be inlined into any modules
that use this module.  This is useful to speed up simulation time with some
small loss of trace visibility and modularity.  Note signals under inlined
submodules will be named I<submodule>__DOT__I<subsignal> as C++ does not
allow "." in signal names.  SystemPerl when tracing such signals will
replace the __DOT__ with the period.

=item /*verilator isolate_assignments*/

Used after a signal declaration to indicate the assignments to this signal
in any blocks should be isolated into new blocks.  When there is a large
combinatorial block that is resulting in a UNOPTFLAT warning, attaching
this to the signal causing a false loop may clear up the problem.

IE, with the following

    reg splitme /* verilator isolate_assignments*/;
    always @* begin
      if (....) begin
         splitme = ....;
         other assignments
      end
    end

Verilator will internally split the block that assigns to "splitme" into
two blocks:

It would then internally break it into (sort of):

    // All assignments excluding those to splitme
    always @* begin
      if (....) begin
         other assignments
      end
    end
    // All assignments to splitme
    always @* begin
      if (....) begin
         splitme = ....;
      end
    end

=item /*verilator lint_off I<msg>*/

Disable the specified warning message for any warnings following the comment.

=item /*verilator lint_on I<msg>*/

Re-enable the specified warning message for any warnings following the comment.

=item /*verilator no_inline_task*/ 

Used in a function or task variable definition section to specify the
function or task should not be inlined into where it is used.  This may
reduce the size of the final executable when a task is used a very large
number of times.  For this flag to work, the task and tasks below it must
be pure; they cannot reference any variables outside the task itself.

=item /*verilator public*/ (variable)

Used after a input, output, register, or wire declaration to indicate the
signal should be declared so that C code may read or write the value
of the signal.  This will also declare this module public, otherwise use
/*verilator public_flat*/.

=item /*verilator public*/ (task/function)

Used inside the declaration section of a function or task declaration to
indicate the function or task should be made into a C++ function, public to
outside callers.  Public tasks will be declared as a void C++ function,
public functions will get the appropriate non-void (bool, uint32_t, etc)
return type.  Any input arguments will become C++ arguments to the
function.  Any output arguments will become C++ reference arguments.  Any
local registers/integers will become function automatic variables on the
stack.

Wide variables over 64 bits cannot be function returns, to avoid exposing
complexities.  However, wide variables can be input/outputs; they will be
passed as references to an array of 32 bit numbers.

This feature is still somewhat experimental.  Generally, only the values of
stored state (flops) should be written, as the model will NOT notice
changes made to variables in these functions.  (Same as when a signal is
declared public.)

=item /*verilator public_flat*/ (variable)

Used after a input, output, register, or wire declaration to indicate the
signal should be declared so that C code may read or write the value of the
signal.  This will not declare this module public, which means the name of
the signal or path to it may change based upon the module inlining which
takes place.

=item /*verilator public_module*/

Used after a module statement to indicate the module should not be inlined
(unless specifically requested) so that C code may access the module.
Verilator automatically sets this attribute when the module contains any
public signals or `systemc_ directives.  Also set for all modules when
using the --public switch.

=item /*verilator sc_clock*/

Used after a input declaration to indicate the signal should be declared in
SystemC as a sc_clock instead of a bool.

=item /*verilator tracing_off*/

Disable waveform tracing for all future signals that are declared in this
module.  Often this is placed just after a primitive's module statement, so
that the entire module is not traced.

=item /*verilator tracing_on*/

Re-enable waveform tracing for all future signals that are declared.

=back

=head1 LANGUAGE LIMITATIONS

There are some limitations and lack of features relative to a commercial
simulator, by intent.  User beware.

It is strongly recommended you use a lint tool before running this program.
Verilator isn't designed to easily uncover common mistakes that a lint
program will find for you.

=head2 Synthesis Subset

Verilator supports only the Synthesis subset with a few minor additions
such as $stop, $finish and $display.  That is, you cannot use hierarchical
references, events or similar features of the Verilog language.  It also
simulates as Synopsys's Design Compiler would; namely a block of the form

	always @ (x)   y = x & z;

will recompute y when there is a change in x or a change in z, which is
what Design Compiler will synthesize.  A compliant simulator would only
calculate y if x changes.  (Use verilog-mode's /*AS*/ or Verilog 2001's
always @* to prevent these issues.)

=head2 Dotted cross-hierarchy references

Verilator supports dotted references to variables, functions and tasks in
different modules. However, references into named blocks and function-local
variables are not supported.  The portion before the dot must have a
constant value; for example a[2].b is acceptable, while a[x].b is not.

References into generated and arrayed instances use the instance names
specified in the Verilog standard; arrayed instances are named
{cellName}[{instanceNumber}] in Verilog, which becomes
{cellname}__BRA__{instanceNumber}__KET__ inside the generated C++ code.

Verilator creates numbered "genblk" when a begin: name is not specified
around a block inside a generate statement.  These numbers may differ
between other simulators, but the Verilog specification does not allow
users to use these names, so it should not matter.

If you are having trouble determining where a dotted path goes wrong, note
that Verilator will print a list of known scopes to help your debugging.

=head2 Latches

Verilator is optimized for edge sensitive (flop based) designs.  It will
attempt to do the correct thing for latches, but most performance
optimizations will be disabled around the latch.

=head2 Time

All delays (#) are ignored, as they are in synthesis.

=head2 Two State

Verilator is a two state simulator, not a four state simulator.  However, it
has two features which uncover most initialization bugs (including many that
a four state simulator will miss.)

First, assigning a variable to a X will actually assign the variable to a
random value (see the -x-assign switch.)  Thus if the value is actually
used, the random value should cause downstream errors.  Integers also
randomize, even though the Verilog 2001 specification says they initialize
to zero.

Identity comparisons (=== or !==) are converted to standard ==/!== when
neither side is a constant.  This may make the expression result differ
from a four state simulator.

All variables are initialized using a function.  By running several
random simulation runs you can determine that reset is working correctly.
On the first run, the function initializes variables to zero.  On the
second, have it initialize variables to one.  On the third and following
runs have it initialize them randomly.  If the results match, reset works.
(Note this is what the hardware will really do.)  In practice, just setting
all variables to one at startup finds most problems.

=head2 Tri/Inout

As a 2 state compiler, tristate and inouts are not supported.
Traditionally only chip "cores" are Verilated, the pad rings have been
written by hand in C++.

=head2 Functions & Tasks

All functions and tasks will be inlined (will not become functions in C.)
The only support provided is for simple statements in tasks (which may
affect global variables).

Recursive functions and tasks are not supported.  All inputs and outputs
are automatic, as if they had the Verilog 2001 "automatic" keyword
prepended.  (If you don't know what this means, Verilator will do what you
probably expect -- what C does. The default behavior of Verilog is
different.)

=head2 Generated Clocks

Verilator attempts to deal with generated clocks correctly, however new
cases may turn up bugs in the scheduling algorithm.  The safest option is
to have all clocks as primary inputs to the model.

=head2 Ranges must be big-bit-endian

Bit ranges must be numbered with the MSB being numbered greater or the same
as the LSB.  Little-bit-endian busses [0:15] are not supported as they
aren't easily made compatible with C++.

=head2 32-Bit Divide

The division and modulus operators are limited to 32 bits.  This can be
easily fixed if someone contributes the appropriate wide-integer math
functions.

=head2 Gate Primitives

The 2-state gate primitives (and, buf, nand, nor, not, or, xnor, xor) are
directly converted to behavioral equivalents.  The 3-state and MOS gate
primitives are not supported.  Tables are not supported.

=head2 Specify blocks

All specify blocks and timing checks are ignored.

=head2 Array Initialization

When initializing an array, you need to use non-delayed assignments.  This
is done in the interest of speed; if delayed assignments were used, the
simulator would have to copy large arrays every cycle.  (In smaller loops,
loop unrolling allows the delayed assignment to work, though it's a bit
slower then a non-delayed assignment.)  Here's an example

	always @ (posedge clk)
            if (~reset_l) begin
                for (i=0; i<`ARRAY_SIZE; i++) begin
		    array[i] = 0;	 // Non-delayed for verilator
                end

=head2 Array Out of Bounds

Writing a memory element that is outside the bounds specified for the array
may cause a different memory element inside the array to be written
instead.  For power-of-2 sized arrays, Verilator will give a width warning
and the address.  For non-power-of-2-sizes arrays, index 0 will be written.

Reading a memory element that is outside the bounds specified for the array
will give a width warning and wrap around the power-of-2 size.  For
non-power-of-2 sizes, it will return a unspecified constant of the
appropriate width.

=head2 Assertions

Verilator is beginning to add support for assertions.  Verilator currently
only converts assertions to simple "if (...) error" statements, and
coverage statements to increment the line counters described in the
coverage section.

Verilator does not support SEREs yet.  All assertion and coverage
statements must be simple expressions that complete in one cycle.
(Arguably SEREs are much of the point, but one must start somewhere.)

=head1 LANGUAGE KEYWORD LIMITATIONS

This section describes specific limitations for each language keyword.

=over 4

=item always, always_comb, always_ff, always_latch, and, assign, begin,
buf, case, casex, casez, default, defparam, do-while, else, end, endcase,
endfunction, endgenerate, endmodule, endspecify, endtask, final, for,
function, generate, genvar, if, initial, inout, input, integer, localparam,
macromodule, module, nand, negedge, nor, not, or, output, parameter,
posedge, reg, scalared, signed, supply0, supply1, task, tri, vectored,
while, wire, xnor, xor

Generally supported.

=item specify specparam

All specify blocks and timing checks are ignored.

=item uwire

Verilator does not perform warning checking on uwires, it treats the uwire
keyword as if it were the normal wire keyword.

=item $bits, $countones, $finish, $isunknown, $onehot, $onehot0, $readmemb,
$readmemh, $signed, $stop, $time, $unsigned

Generally supported.

=item $display, $write, $fdisplay, $fwrite

$display and friends must have a constant format string as the first
argument (as with C's printf), you cannot simply list variables standalone.

=item $displayb, $displayh, $displayo, $writeb, $writeh, $writeo, etc

The sized display functions are rarely used and so not supported.  Replace
them with a $write with the appropriate format specifier.

=item $fopen, $fclose, $fdisplay, $fwrite

File descriptors passed to the file PLI calls must be file descriptors, not
MCDs, which includes the mode parameter to $fopen being mandatory.
Verilator will convert the integer used to hold the file descriptor into a
internal FILE*. To prevent core dumps due to mis-use, and because integers
are 32 bits while FILE*s may be 64 bits, the descriptor must be stored in a
reg [63:0] rather then an integer.  The define `verilator_file_descriptor in
verilated.v can be used to hide this difference.

=item $fullskew, $hold, $nochange, $period, $recovery, $recrem, $removal,
$setup, $setuphold, $skew, $timeskew, $width

All specify blocks and timing checks are ignored.

=item $readmemb, $readmemh

Read memory commands should work properly.  Note Verilator and the Verilog
specification does not include support for readmem to multi-dimensional
arrays.

=item $realtime

Treated as $time.

=back

=head1 ERRORS AND WARNINGS

Warnings may be disabled in two ways.  First, when the warning is
printed it will include a warning code.  Simply surround the offending
line with a warn_off/warn_on pair:

	// verilator lint_off UNSIGNED
	if (`DEF_THAT_IS_EQ_ZERO <= 3) $stop;
	// verilator lint_on UNSIGNED

Warnings may also be globally disabled by invoking Verilator with the
C<-Wno-I<warning>> switch.  This should be avoided, as it removes all
checking across the designs, and prevents other users from compiling your
code without knowing the magic set of disables needed to successfully
compile your design.

List of all warnings:

=over 4

=item BLKANDNBLK

Error that a variable comes from a mix of blocked and non-blocking
assignments.  Generally, this is caused by a register driven by both combo
logic and a flop:

      always @ (posedge clk)  foo[0] <= ...
      always @* foo[1] = ...

Simply use a different register for the flop:

      always @ (posedge clk)  foo_flopped[0] <= ...
      always @* foo[0] = foo_flopped[0];
      always @* foo[1] = ...

This is good coding practice anyways.

It is also possible to disable this error when one of the assignments is
inside a public task.

=item CASEINCOMPLETE

Warns that inside a case statement there is a stimulus pattern for which
there is no case item specified.  This is bad style, if a case is
impossible, it's better to have a "default: $stop;" or just "default: ;" so
that any design assumption violations will be discovered in simulation.

=item CASEOVERLAP

Warns that inside a case statement you have case values which are detected
to be overlapping.  This is bad style, as moving the order of case values
will cause different behavior.  Generally the values can be respecified to
not overlap.

=item CASEX

Warns that it is simply better style to use casez, and C<?> in place of
C<x>'s.  See
L<http://www.sunburst-design.com/papers/CummingsSNUG1999Boston_FullParallelCase_rev1_1.pdf>

=item CMPCONST

Warns that you are comparing a value in a way that will always be constant.
For example "X > 1" will always be true when X is a single bit wide.

=item COMBDLY

Warns that you have a delayed assignment inside of a combinatorial block.
Using delayed assignments in this way is considered bad form, and may lead
to the simulator not matching synthesis.  If this message is suppressed,
Verilator, like synthesis, will convert this to a non-delayed assignment,
which may result in logic races or other nasties.  See
L<http://www.sunburst-design.com/papers/CummingsSNUG2000SJ_NBA_rev1_2.pdf>

=item GENCLK

Warns that the specified signal is generated, but is also being used as a
clock.  Verilator needs to evaluate sequential logic multiple times in this
situation. In somewhat contrived cases having any generated clock can
reduce performance by almost a factor of two.  For fastest results,
generate ALL clocks outside in C++/SystemC and make them primary inputs to
your Verilog model.  (However once need to you have even one, don't sweat
additional ones.)

=item IMPLICIT

Warns that a wire is being implicitly declared (it is a single bit wide
output from a sub-module.)  While legal in Verilog, implicit declarations
only work for single bit wide signals (not buses), do not allow using a
signal before it is implicitly declared by a cell, and can lead to dangling
nets.  A better option is the /*AUTOWIRE*/ feature of Verilog-Mode for
Emacs, available from L<http://www.veripool.com/>

=item IMPURE

Warns that a task or function that has been marked with /*verilator
no_inline_task*/ references variables that are not local to the task.
Verilator cannot schedule these variables correctly.

=item MULTIDRIVEN

Warns that the specified signal comes from multiple always blocks.  This is
often unsupported by synthesis tools, and is considered bad style.  It will
also cause longer runtimes due to reduced optimizations.

=item MULTITOP

Error that there are multiple top level modules, that is modules not
instantiated by any other module.  Verilator only supports a single top
level, if you need more, create a module that wraps all of the top modules.

Often this error is because some low level cell is being read in, but is
not really needed.  The best solution is to insure that each module is in a
unique file by the same name.  Otherwise, make sure all library files are
read in as libraries with -v, instead of automatically with -y.

=item TASKNSVAR

Error when a call to a task or function has a output from that task tied to
a non-simple signal.  Instead connect the task output to a temporary signal
of the appropriate width, and use that signal to set the appropriate
expression as the next statement.  For example:

      task foo; output sig; ... endtask
      always @* begin
           foo(bus_we_select_from[2]);   // Will get TASKNSVAR error
      end

Change this to:

      reg foo_temp_out;
      always @* begin
           foo(foo_temp_out);
           bus_we_select_from[2] = foo_temp_out;
      end

Verilator doesn't do this conversion for you, as some more complicated
cases would result in simulator mismatches.

=item UNDRIVEN

Warns that the specified signal is never sourced.

=item UNOPT

Warns that due to some construct, optimization of the specified signal or
block is disabled.  The construct should be cleaned up to improve runtime.

A less obvious case of this is when a module instantiates two submodules.
Inside submodule A, signal I is input and signal O is output.  Likewise in
submodule B, signal O is an input and I is an output.  A loop exists and a
UNOPT warning will result if AI & AO both come from and go to combinatorial
blocks in both submodules, even if they are unrelated always blocks.  This
affects performance because Verilator would have to evaluate each submodule
multiple times to stabilize the signals crossing between the modules.

=item UNOPTFLAT

Warns that due to some construct, optimization of the specified signal is
disabled.  The signal specified includes a complete scope to the signal; it
may be only one particular usage of a multiply instantiated block.  The
construct should be cleaned up to improve runtime; two times better
performance may be possible by fixing these warnings.

Unlike the UNOPT warning, this occurs after netlist flattening, and
indicates a more basic problem, as the less obvious case described under
UNOPT does not apply.

Often UNOPTFLAT is caused by logic that isn't truly circular as viewed by
synthesis which analyzes interconnection per-bit, but is circular to
simulation which analyzes per-bus:

      wire [2:0] x = {x[1:0],shift_in};

This statement needs to be evaluated multiple times, as a change in
"shift_in" requires "x" to be computed 3 times before it becomes stable.
This is because a change in "x" requires "x" itself to change value, which
causes the warning.

For significantly better performance, split this into 2 separate signals:

      wire [2:0] xout = {x[1:0],shift_in};

and change all receiving logic to instead receive "xout".  Alternatively,
change it to

      wire [2:0] x = {xin[1:0],shift_in};

and change all driving logic to instead drive "xin".

With this change this assignment needs to be evaluated only once.  These
sort of changes may also speed up your traditional event driven simulator,
as it will result in fewer events per cycle.

The most complicated UNOPTFLAT path we've seen was due to low bits of a bus
being generated from an always statement that consumed high bits of the
same bus processed by another series of always blocks.  The fix is the
same; split it into two separate signals generated from each block.

The UNOPTFLAT warning may also be due to clock enables, identified from the
reported path going through a clock gating cell.  To fix these, use the
clock_enable meta comment described above.

The UNOPTFLAT warning may also occur where outputs from a block of logic
are independent, but occur in the same always block.  To fix this, use the
isolate_assignments meta comment described above.

=item UNSIGNED

Warns that you are comparing a unsigned value in a way that implies it is
signed, for example "X < 0" will always be true when X is unsigned.

=item UNUSED

Warns that the specified signal is never sinked.  This is a future message,
currently Verilator will not produce this warning.

=item VARHIDDEN

Warns that a task, function, or begin/end block is declaring a variable by
the same name as a variable in the upper level module or begin/end block
(thus hiding the upper variable from being able to be used.)  Rename the
variable to avoid confusion when reading the code.

=item WIDTH

Warns that based on width rules of Verilog, two operands have different
widths.  Verilator generally can intuit the common usages of widths, and
you shouldn't need to disable this message like you do with most lint
programs.  Generally other then simple mistakes, you have two solutions:

If it's a constant 0 that's 32 bits or less, simply leave it
unwidthed. Verilator considers zero to be any width needed.

Concatenate leading zeros when doing arithmetic.  In the statement

	wire [5:0] plus_one = from[5:0] + 6'd1 + carry[0];

The best fix, which clarifies intent and will also make all tools happy is:

	wire [5:0] plus_one = from[5:0] + 6'd1 + {5'd0,carry[0]};

=back

The following describes the less obvious errors:

=over 4

=item Internal Error

This error should never occur first, though may occur if earlier warnings
or error messages have corrupted the program.  If there are no other
warnings or errors, submit a bug report.

=item Unsupported: ....

This error indicates that you are using a Verilog language construct
that is not yet supported in Verilator.  See the Limitations chapter.

=item Verilated model didn't converge

Verilator sometimes has to evaluate combinatorial logic multiple times,
usually around code where a UNOPTFLAT warning was issued, but disabled.
For example:

   always @ (a)  b=~a;
   always @ (b)  a=b

will toggle forever and thus the executable will give the didn't converge
error to prevent an infinite loop.

To debug this, run Verilator with --profile-cfuncs.  Run make on the
generated files with "OPT=-DVL_DEBUG". Then call Verilated::debug(1) in
your main.cpp.

This will cause each change in a variable to print a message.  Near the
bottom you'll see the code and variable that causes the problem.  For the
program above:

        CHANGE: filename.v:1: b
        CHANGE: filename.v:2: a

=back

=head1 FAQ/FREQUENTLY ASKED QUESTIONS

=over 4

=item Does it run under Windows?

Yes, using Cygwin.  Verilated output should also compile under Microsoft
Visual C++ Version 7 or newer, but this is not tested by the author.

=item Can you provide binaries?

At this time I'd prefer to get patches out quickly then have to generate
myriad binaries for many different OS flavors.  People have generally
requested binaries when they are having problems with their C++
compiler. Alas, binaries won't help this, as in the end a fully working C++
compiler is required to compile the output of Verilator.

=item How can it be faster then (name-the-simulator)?

Generally, the implied part of the question is "... with all of their
manpower they can put into it."

Most commercial simulators have to be Verilog compliant, meaning event
driven.  This prevents them from being able to reorder blocks and make
netlist-style optimizations, which are where most of the gains come from.

Non-compliance shouldn't be scary.  Your synthesis program isn't compliant,
so your simulator shouldn't have to be -- and Verilator is closer to the
synthesis interpretation, so this is a good thing for getting working
silicon.

=item How do I generate waveforms (traces) in C++?

See the next question for SystemC mode.

Add the --trace switch to Verilator, and make sure the SystemPerl package
is installed. SystemC itself does not need to be installed for C++ only
tracing.  You do not even need to compile SystemPerl; you may simply untar
the SystemPerl kit and point the SYSTEMPERL environment variable to the
untarred directory.

In your top level C code, call Verilated::traceEverOn(true).  Then create a
SpTraceVcdC object.  For an example, see the call to SpTraceVcdC in the
test_c/sc_main.cpp file of the distribution.

You also need to compile SpTraceVcdC.cpp and add it to your link.  This is
done for you if using the Verilator --exe flag.

=item How do I generate waveforms (traces) in SystemC?

Add the --trace switch to Verilator, and make sure the SystemPerl package
is installed.

In your top level C sc_main code, call Verilated::traceEverOn(true).  Then
create a SpTraceFile object as you would create a normal SystemC trace
file.  For an example, see the call to SpTraceFile in the
test_sp/sc_main.cpp file of the distribution.

=item How do I view waveforms (traces)?

Verilator makes standard VCD (Value Change Dump) files.  They are viewable
with the public domain Dinotrace or GtkWave programs, or any of the many
commercial offerings.

=item Where is the translate_off command?  (How do I ignore a construct?)

Translate on/off pragmas are generally a bad idea, as it's easy to have
mismatched pairs, and you can't see what another tool sees by just
preprocessing the code.  Instead, use the preprocessor; Verilator defines
the "verilator" define for you, so just wrap the code in a ifndef region:

   `ifndef verilator
      Something_Verilator_Dislikes;
   `endif

=item How do I prevent my assertions from firing during reset?

Call Verilated::assertOn(false) before you first call the model, then turn
it back on after reset.  It defaults to true.  When false, all assertions
controlled by --assert are disabled.

=item Why do I get "undefined reference to `sc_time_stamp()'"?

In C++ (non SystemC) code you need to define this function so that the
simulator knows the current time.  See the "CONNECTING TO C++" examples.

=item Why do I get "undefined reference to `VL_RAND_RESET_I' or `Verilated::...'"?

You need to link your compiled Verilated code against the verilated.cpp
file found in the include directory of the Verilator kit.

=item Is the PLI supported?

No.

More specifically, the common PLI-ish calls $display, $finish, $stop,
$time, $write are converted to C++ equivalents.  If you want something more
complex, since Verilator emits standard C++ code, you can simply write your
own C++ routines that can access and modify signal values without needing
any PLI interface code, and call it with $c("{any_c++_statement}").

=item How do I make a Verilog module that contain a C++ object?

You need to add the object to the structure that Verilator creates, then
use $c to call a method inside your object.  The
test_regress/t/t_extend_class files show an example of how to do this.

=item How do I get faster build times?

Between GCC 3.0 to 3.3, each compiled progressively slower, thus if you can
use GCC 2.95, or GCC 3.4 you'll have faster builds.  Two ways to cheat are
to compile on parallel machines and avoid compilations altogether.  See the
--output-split option, and the web for the ccache, distcc and icecream
packages, and the Make::Cache package available from
L<http://www.veripool.com/>. Make::Cache will skip GCC runs between
identical source builds, even across different users.

=item Why do so many files need to recompile when I add a signal?

Adding a new signal requires the symbol table to be recompiled.  Verilator
uses one large symbol table, as that results in 2-3 less assembly
instructions for each signal access.  This makes the execution time 10-15%
faster, but can result in more compilations when something changes.

=item How do I access signals in C?

First, declare the signals you will be accessing with a /*verilator
public*/ comment before the closing semicolon.  Then scope into the C++
class to read the value of the signal, as you would any other member variable.

Signals are the smallest of 8 bit chars, 16 bit shorts, 32 bit longs, or 64
bit long longs that fits the width of the signal.  Generally, you can use
just uint32_t's for 1 to 32 bits, or uint64_t for 1 to 64 bits, and the
compiler will properly up-convert smaller entities.

Signals wider then 64 bits are stored as an array of 32-bit uint32_t's.
Thus to read bits 31:0, access signal[0], and for bits 63:32, access
signal[1].  Unused bits (for example bit numbers 65-96 of a 65 bit vector)
will always be zero.  if you change the value you must make sure to pack
zeros in the unused bits or core-dumps may result.  (Because Verilator
strips array bound checks where it believes them to be unnecessary.)

In the SYSTEMC example above, if you had in our.v:

         input clk /*verilator public*/;

From the sc_main.cpp file, you'd then:

    #include "Vour.h"
    #include "Vour_our.h"
    cout << "clock is " << top->v.clk << endl;

In this example, clk is a bool you can read or set as any other variable.
The value of normal signals may be set, though clocks shouldn't be changed
by your code or you'll get strange results.

=item Should a module be in Verilog or SystemC?

Sometimes there is a block that just interconnects cells, and have a choice
as to if you write it in Verilog or SystemC.  Everything else being equal,
best performance is when Verilator sees all of the design.  So, look at the
hierarchy of your design, labeling cells as to if they are SystemC or
Verilog.  Then:

A module with only SystemC cells below must be SystemC.

A module with a mix of Verilog and SystemC cells below must be SystemC. (As
Verilator cannot connect to lower-level SystemC cells.)

A module with only Verilog cells below can be either, but for best
performance should be Verilog.  (The exception is if you have a design that
is instantiated many times; in this case Verilating one of the lower
modules and instantiating that Verilated cells multiple times into a
SystemC module *may* be faster.)

=back

=head1 BUGS

First, check the the coding limitations section.

Next, try the --debug switch.  This will enable additional internal
assertions, and may help identify the problem.

Finally, reduce your code to the smallest possible routine that exhibits
the bug.  Even better, create a test in the test_regress/t directory, as
follows:

    cd test_regress
    cp -p t/t_EXAMPLE.pl t/t_BUG.pl
    cp -p t/t_EXAMPLE.v t/t_BUG.v

Edit t/t_BUG.pl to suit your example; you can do anything you want in the
Verilog code there; just make sure it retains the single clk input and no
outputs.  Now, the following should fail:

    cd test_regress
    t/t_BUG.pl

Finally, Mail the bug report to C<wsnyder@wsnyder.org>.

=head1 HISTORY

Verilator was conceived in 1994 by Paul Wasson at the Core Logic Group
at Digital Equipment Corporation.  The Verilog code that was converted
to C was then merged with a C based CPU model of the Alpha processor
and simulated in a C based environment called CCLI.

In 1995 Verilator started being used also for Multimedia and Network
Processor development inside Digital.  Duane Galbi took over active
development of Verilator, and added several performance enhancements.
CCLI was still being used as the shell.

In 1998, through the efforts of existing DECies, mainly Duane Galbi,
Digital graciously agreed to release the source code.  (Subject to the
code not being resold, which is compatible with the GNU Public
License.)

In 2001, Wilson Snyder took the kit, and added a SystemC mode, and
called it Verilator2.  This was the first packaged public release.

In 2002, Wilson Snyder created Verilator3 by rewriting Verilator from
scratch in C++.  This added many optimizations, yielding about a 2-5x
performance gain.

Currently, various language features and performance enhancements are added
as the need arises.  Verilator is now about 2x faster then in 2002, and is
faster then many popular commercial simulators.

=head1 CONTRIBUTORS

Many people have provided ideas and other assistance with Verilator.

The major corporate sponsors of Verilator, by providing funds or equipment
grants, are Compaq Corporation, Digital Equipment Corporation, Maker
Communications, Sun Microsystems, Nauticus Networks, and SiCortex.

The people who have contributed code or other major functionality are Paul
Wasson, Duane Galbi, and Wilson Snyder.  Major testers include Jeff Dutton,
Ralf Karge and Wim Michiels.

Some of the people who have provided ideas and feedback for Verilator
include Hans Van Antwerpen, Jens Arm, David Black, Gregg Bouchard, Chris
Boumenot, John Brownlee, Lauren Carlson, Robert A. Clark, John Deroo, Danny
Ding, Jeff Dutton, Eugen Fekete, Sam Gladstone, Thomas Hawkins, Mike Kagen,
Ralf Karge, Dan Katz, Sol Katzman, Gernot Koch, Steve Kolecki, Steve Lang,
Charlie Lind, Dan Lussier, Fred Ma, Wim Michiels, John Murphy, Richard
Myers, Paul Nitza, Lisa Noack, Renga Sundararajan, Shawn Wang, Greg Waters,
Eugene Weber, Leon Wildman, and Mat Zeno.

=head1 DISTRIBUTION

The latest version is available from L<http://www.veripool.com/>.

Copyright 2003-2007 by Wilson Snyder.  Verilator is free software; you can
redistribute it and/or modify it under the terms of either the GNU Lesser
General Public License or the Perl Artistic License.

=head1 AUTHORS

Wilson Snyder <wsnyder@wsnyder.org>

Major concepts by Paul Wasson and Duane Galbi.

=head1 SEE ALSO

L<systemperl>, L<vcoverage>, L<make>

=cut

######################################################################
