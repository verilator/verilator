//      // verilator_coverage annotation
        // DESCRIPTION: Verilator: Verilog Test module
        //
        // This file ONLY is placed under the Creative Commons Public Domain, for
        // any use, without warranty, 2008 by Wilson Snyder.
        // SPDX-License-Identifier: CC0-1.0
        
        module t (/*AUTOARG*/
           // Inputs
           clk
           );
        
           input clk;
        
           reg   toggle;
           initial toggle=0;
        
           integer cyc;
           initial cyc=1;
        
           wire [7:0] cyc_copy = cyc[7:0];
        
           alpha a1 (/*AUTOINST*/
                     // Inputs
                     .clk                       (clk),
                     .toggle                    (toggle));
           alpha a2 (/*AUTOINST*/
                     // Inputs
                     .clk                       (clk),
                     .toggle                    (toggle));
           beta  b1 (/*AUTOINST*/
                     // Inputs
                     .clk                       (clk),
                     .toggle                    (toggle));
           beta  b2 (/*AUTOINST*/
                     // Inputs
                     .clk                       (clk),
                     .toggle                    (toggle));
           tsk   t1 (/*AUTOINST*/
                     // Inputs
                     .clk                       (clk),
                     .toggle                    (toggle));
           off   o1 (/*AUTOINST*/
                     // Inputs
                     .clk                       (clk),
                     .toggle                    (toggle));
           tab tab1 (/*AUTOINST*/
                     // Inputs
                     .clk                       (clk));
           par par1 (/*AUTOINST*/);
           cond cond1 (/*AUTOINST*/
                       // Inputs
                       .clk                     (clk),
                       .cyc                     (cyc));
        
           always @ (posedge clk) begin
~000010       if (cyc!=0) begin
+000010  point: comment=if hier=top.t
-000000  point: comment=else hier=top.t
 000010          cyc <= cyc + 1;
+000010  point: comment=if hier=top.t
 000010          toggle <= '0;
+000010  point: comment=if hier=top.t
                 // Single and multiline if
%000009          if (cyc==3) $write("");
-000001  point: comment=if hier=top.t
-000009  point: comment=else hier=top.t
%000009          if (cyc==3)
-000001  point: comment=if hier=top.t
-000009  point: comment=else hier=top.t
%000001            begin
-000001  point: comment=if hier=top.t
%000001               $write("");
-000001  point: comment=if hier=top.t
                   end
                 // Single and multiline else
%000009          if (cyc==3) ; else $write("");
-000001  point: comment=if hier=top.t
-000009  point: comment=else hier=top.t
%000009          if (cyc==3) ;
-000001  point: comment=if hier=top.t
-000009  point: comment=else hier=top.t
                 else
%000009            begin
-000009  point: comment=else hier=top.t
%000009               $write("");
-000009  point: comment=else hier=top.t
                   end
                 // Single and multiline if else
%000009          if (cyc==3) $write(""); else $write("");
-000001  point: comment=if hier=top.t
-000009  point: comment=else hier=top.t
%000009          if (cyc==3)
-000001  point: comment=if hier=top.t
-000009  point: comment=else hier=top.t
%000001            begin
-000001  point: comment=if hier=top.t
%000001               $write("");
-000001  point: comment=if hier=top.t
                   end
                 else
%000009            begin
-000009  point: comment=else hier=top.t
%000009               $write("");
-000009  point: comment=else hier=top.t
                   end
                 //  multiline elseif
                 if (cyc==3)
                   begin
                      $write("");
                   end
                 else if (cyc==4)
                   begin
                      $write("");
                   end
                 else if (cyc==5)
                   begin
                      $write("");
                   end
                 else
                   begin
                      $write("");
                   end
                 // Single and multiline while
                 while (0);
                 while (0) begin
                    $write("");
                 end
                 do ; while (0);
 000010          do begin
+000010  point: comment=if hier=top.t
 000010             $write("");
+000010  point: comment=if hier=top.t
                 end while (0);
                 //===
                 // Task and complicated
                 if (cyc==3) begin
                    toggle <= '1;
                 end
                 else if (cyc==5) begin
        `ifdef VERILATOR
                    $c("this->call_task();");
        `else
                    call_task();
        `endif
                 end
%000007          else if (cyc==10) begin
-000001  point: comment=if hier=top.t
-000007  point: comment=else hier=top.t
%000001             $write("*-* All Finished *-*\n");
-000001  point: comment=if hier=top.t
%000001             $finish;
-000001  point: comment=if hier=top.t
                 end
              end
           end
        
           task call_task;
              /* verilator public */
              t1.center_task(1'b1);
           endtask
        
        endmodule
        
        module alpha (/*AUTOARG*/
           // Inputs
           clk, toggle
           );
           input clk;
           input toggle;
           always @ (posedge clk) begin
~000018       if (toggle) begin  // CHECK_COVER(0,"top.t.a*",18)
-000002  point: comment=if hier=top.t.a*
+000018  point: comment=else hier=top.t.a*
%000002          $write("");
-000002  point: comment=if hier=top.t.a*
                 // t.a1 and t.a2 collapse to a count of 2
              end
              if (toggle) begin  // *** t_cover_line.vlt turns this off
                 $write("");  // CHECK_COVER_MISSING(0)
                 // This doesn't even get added
        `ifdef ATTRIBUTE
                 // verilator coverage_block_off
        `endif
              end
           end
        endmodule
        
        module beta (/*AUTOARG*/
           // Inputs
           clk, toggle
           );
           input clk;
           input toggle;
        
           /* verilator public_module */
        
           always @ (posedge clk) begin
              $write("");  // Always covered
~000020       if (0) begin  // CHECK_COVER(0,"top.t.b*",0)
-000000  point: comment=if hier=top.t.b*
+000020  point: comment=else hier=top.t.b*
                 // Make sure that we don't optimize away zero buckets
%000000          $write("");
-000000  point: comment=if hier=top.t.b*
              end
~000018       if (toggle) begin  // CHECK_COVER(0,"top.t.b*",2)
-000002  point: comment=if hier=top.t.b*
+000018  point: comment=else hier=top.t.b*
                 // t.b1 and t.b2 collapse to a count of 2
%000002          $write("");
-000002  point: comment=if hier=top.t.b*
              end
              if (toggle) begin : block
                 // This doesn't
        `ifdef ATTRIBUTE
                 // verilator coverage_block_off
        `endif
                 begin end  // *** t_cover_line.vlt turns this off (so need begin/end)
                 if (1) begin end  // CHECK_COVER_MISSING(0)
                 $write("");  // CHECK_COVER_MISSING(0)
              end
           end
        endmodule
        
        class Cls;
           bit m_toggle;
           function new(bit toggle);
              m_toggle = toggle;
%000001       if (m_toggle) begin  // CHECK_COVER(0,"top.$unit::Cls",1)
-000001  point: comment=if hier=top.$unit::Cls__Vclpkg
-000000  point: comment=else hier=top.$unit::Cls__Vclpkg
%000001          $write("");
-000001  point: comment=if hier=top.$unit::Cls__Vclpkg
              end
           endfunction
           static function void fstatic(bit toggle);
~000011       if (1) begin  // CHECK_COVER(0,"top.$unit::Cls",1)
+000011  point: comment=if hier=top.$unit::Cls__Vclpkg
-000000  point: comment=else hier=top.$unit::Cls__Vclpkg
 000011          $write("");
+000011  point: comment=if hier=top.$unit::Cls__Vclpkg
              end
           endfunction
           function void fauto();
~000011       if (m_toggle) begin  // CHECK_COVER(0,"top.$unit::Cls",11)
+000011  point: comment=if hier=top.$unit::Cls__Vclpkg
-000000  point: comment=else hier=top.$unit::Cls__Vclpkg
 000011          $write("");
+000011  point: comment=if hier=top.$unit::Cls__Vclpkg
              end
           endfunction
        endclass
        
        module tsk (/*AUTOARG*/
           // Inputs
           clk, toggle
           );
           input clk;
           input toggle;
        
           /* verilator public_module */
        
           always @ (posedge clk) begin
              center_task(1'b0);
           end
        
           task center_task;
              input external;
              begin
~000010          if (toggle) begin  // CHECK_COVER(0,"top.t.t1",1)
-000001  point: comment=if hier=top.t.t1
+000010  point: comment=else hier=top.t.t1
%000001             $write("");
-000001  point: comment=if hier=top.t.t1
                 end
~000010          if (external) begin  // CHECK_COVER(0,"top.t.t1",1)
-000001  point: comment=if hier=top.t.t1
+000010  point: comment=else hier=top.t.t1
%000001             $write("[%0t] Got external pulse\n", $time);
-000001  point: comment=if hier=top.t.t1
                 end
              end
              begin
                 Cls c = new(1'b1);
                 c.fauto();
                 Cls::fstatic(1'b1);
              end
           endtask
        endmodule
        
        module off (/*AUTOARG*/
           // Inputs
           clk, toggle
           );
           input clk;
           input toggle;
        
           // verilator coverage_off
           always @ (posedge clk) begin
              if (toggle) begin
                 $write("");  // CHECK_COVER_MISSING(0)
                 // because under coverage_module_off
              end
           end
           // verilator coverage_on
           always @ (posedge clk) begin
%000009       if (toggle) begin
-000001  point: comment=if hier=top.t.o1
-000009  point: comment=else hier=top.t.o1
                 // because under coverage_module_off
%000001          $write("");
-000001  point: comment=if hier=top.t.o1
%000001          if (0) ;  // CHECK_COVER(0,"top.t.o1",1)
-000000  point: comment=if hier=top.t.o1
-000001  point: comment=else hier=top.t.o1
              end
           end
        endmodule
        
        module tab (input clk);
           bit [3:0] cyc4;
           int decoded;
        
           always @ (posedge clk) begin
              case (cyc4)
                1: decoded = 10;
                2: decoded = 20;
                3: decoded = 30;
                4: decoded = 40;
                5: decoded = 50;
                default: decoded = 0;
              endcase
           end
        
           always @ (posedge clk) begin
              cyc4 <= cyc4 + 1;
           end
        endmodule
        
        module par();
           localparam int CALLS_FUNC = param_func(1);
        
           // We don't currently count elaboration time use towards coverage.  This
           // seems safer for functions used both at elaboration time and not - but may
           // revisit this.
           function automatic int param_func(int i);
%000000       if (i == 0) begin
-000000  point: comment=if hier=top.t.par1
-000000  point: comment=else hier=top.t.par1
%000000          i = 99; // Uncovered
-000000  point: comment=if hier=top.t.par1
              end
%000000       else begin
-000000  point: comment=else hier=top.t.par1
%000000          i = i + 1;
-000000  point: comment=else hier=top.t.par1
              end
              return i;
           endfunction
        
        endmodule
        
        package my_pkg;
           int x = 1 ? 1 : 0;
        endpackage
        
        class Getter1;
           function int get_1;
              return 1;
           endfunction
        endclass
        
        module cond(input logic clk, input int cyc);
           logic a, b, c, d, e, f, g, h, k, l, m;
           logic [5:0] tab;
           typedef logic [7:0] arr_t[1:0];
           arr_t data[1:0];
           Getter1 getter1 = new;
           string s;
        
           function logic func_side_effect;
              $display("SIDE EFFECT");
              return 1;
           endfunction
        
           function arr_t get_arr;
              arr_t arr;
              return arr;
           endfunction
        
~000031    assign a = (cyc == 0) ? clk : 1'bz;
-000000  point: comment=cond_then hier=top.t.cond1
+000031  point: comment=cond_else hier=top.t.cond1
~000028    assign b = (cyc == 1) ? clk : 0;
-000003  point: comment=cond_then hier=top.t.cond1
+000028  point: comment=cond_else hier=top.t.cond1
~000021    assign c = func_side_effect() ? clk : 0;
+000021  point: comment=cond_then hier=top.t.cond1
-000000  point: comment=cond_else hier=top.t.cond1
           always @(posedge clk) begin
%000007       d = (cyc % 3 == 0) ? 1 : 0;
-000003  point: comment=cond_then hier=top.t.cond1
-000007  point: comment=cond_else hier=top.t.cond1
~000010       s = (getter1.get_1() == 0) ? "abcd" : $sformatf("%d", getter1.get_1()[4:0]);
-000000  point: comment=cond_then hier=top.t.cond1
+000010  point: comment=cond_else hier=top.t.cond1
           end
~000019    assign e = (cyc % 3 == 1) ? (clk ? 1 : 0) : 1;
+000012  point: comment=cond_then hier=top.t.cond1
+000019  point: comment=cond_else hier=top.t.cond1
-000007  point: comment=cond_then hier=top.t.cond1
-000005  point: comment=cond_else hier=top.t.cond1
        
           // ternary operator in condition shouldn't be included to the coverae
~000011    assign f = (cyc != 0 ? 1 : 0) ? 1 : 0;
+000011  point: comment=cond_then hier=top.t.cond1
-000000  point: comment=cond_else hier=top.t.cond1
           // the same as in index
           assign tab[clk ? 1 : 0] = 1;
           assign m = tab[clk ? 3 : 4];
        
           for (genvar i = 0; i < 2; i++) begin
 000011       assign g = clk ? 1 : 0;
+000010  point: comment=cond_then hier=top.t.cond1
+000011  point: comment=cond_else hier=top.t.cond1
           end
        
           always begin
~000010       if (cyc == 5) h = cyc > 5 ? 1 : 0;
-000000  point: comment=cond_then hier=top.t.cond1
-000001  point: comment=cond_else hier=top.t.cond1
-000001  point: comment=if hier=top.t.cond1
+000010  point: comment=else hier=top.t.cond1
 000010       else h = 1;
+000010  point: comment=else hier=top.t.cond1
        
~000010       data[0] = (cyc == 2) ? '{8'h01, 8'h02} : get_arr();
-000001  point: comment=cond_then hier=top.t.cond1
+000010  point: comment=cond_else hier=top.t.cond1
        
              // ternary operator in conditions should be skipped
              for (int i = 0; (i < 5) ? 1 : 0; i++) begin
                 k = 1'(i);
              end
              for (int i = 0; i < 7; i = (i > 4) ? i + 1 : i + 2) begin
                 k = 1'(i);
              end
        
~000011       if (k ? 1 : 0) k = 1;
-000000  point: comment=if hier=top.t.cond1
+000011  point: comment=else hier=top.t.cond1
 000011       else k = 0;
+000011  point: comment=else hier=top.t.cond1
           end
        endmodule
        
