// DESCRIPTION: Verilator: Verilog Test module
//
// This file ONLY is placed under the Creative Commons Public Domain, for
// any use, without warranty, 2025 by Geza Lore.
// SPDX-License-Identifier: CC0-1.0

`define signal(name, expr) wire [$bits(expr)-1:0] ``name = expr

module t (
`include "portlist.vh" // Boilerplate generated by t_dfg_break_cycles.py
  rand_a, rand_b, srand_a, srand_b
);

`include "portdecl.vh" // Boilerplate generated by t_dfg_break_cycles.py

  input rand_a;
  input rand_b;
  input srand_a;
  input srand_b;
  wire logic        [63:0] rand_a;
  wire logic        [63:0] rand_b;
  wire logic signed [63:0] srand_a;
  wire logic signed [63:0] srand_b;

  //////////////////////////////////////////////////////////////////////////

  logic [2:0] simple;
  always_comb begin
    simple[0] = rand_a[0];
    simple[1] = rand_a[1];
    simple[2] = rand_a[2];
  end
  `signal(SIMPLE, simple);

  logic [1:0] reassign;
  always_comb begin
    reassign[0] =  rand_a[0];
    reassign[0] = ~rand_a[0];
    reassign[1] =  rand_a[1];
    reassign[1] = ~rand_a[1];
  end
  `signal(REASSIGN, reassign);

  logic [1:0] use_intermediate_a;
  logic [1:0] use_intermediate_b;
  always_comb begin
    use_intermediate_a[0] =  rand_a[0];
    use_intermediate_b[0] = ~use_intermediate_a[0];
    use_intermediate_a[1] =  rand_a[1];
    use_intermediate_a[0] = ~rand_a[0];
    use_intermediate_b[1] = ~use_intermediate_a[1];
    use_intermediate_a[1] = ~rand_a[1];
  end
  `signal(USE_INTERMEDIATE, {use_intermediate_a, use_intermediate_b});

  logic [2:0] self_circular;
  always_comb begin
    self_circular[0] = rand_a[0];
    self_circular[1] = ~self_circular[0];
    self_circular[2] = ~self_circular[1];
  end
  `signal(SELF_CIRCULAR, self_circular);

  logic [2:0] part_circular;
  always_comb begin
    part_circular[0] = rand_a[0];
    part_circular[1] = ~part_circular[0];
  end
  // part_circular[2] deliberately undriven!
  `signal(PART_CIRCULAR, part_circular);

  logic [3:0] split_circular;
  always_comb begin
    split_circular[0] = rand_a[0];
    split_circular[2] = rand_a[1];
  end
  always_comb begin
    split_circular[1] = ~split_circular[0];
    split_circular[3] = ~split_circular[2];
  end
  `signal(SPLIT_CIRCULAR, split_circular);

  logic [3:0] conditional_a;
  always_comb begin
    conditional_a = 4'd0;
    if (rand_a[0]) begin
      conditional_a = rand_b[3:0];
    end else begin
      conditional_a = ~rand_b[3:0];
    end
  end
  `signal(CONDITONAL_A, conditional_a);

  logic [3:0] conditional_b;
  always_comb begin
    conditional_b = 4'd0;
    if (rand_a[0]) begin
      conditional_b = rand_b[3:0];
    end
  end
  `signal(CONDITONAL_B, conditional_b);

  // verilator lint_off LATCH
  logic [3:0] conditional_c;
  always_comb begin // nosynth
    if (rand_a[0]) begin
      conditional_c = rand_b[3:0];
    end
    if (~rand_a[0]) begin
      conditional_c = ~rand_b[3:0];
    end
  end
  `signal(CONDITONAL_C, conditional_c);
  // verilator lint_on LATCH

  logic [3:0] conditional_d;
  always_comb begin
    if (rand_a[0]) begin
      conditional_d = rand_b[3:0];
    end else if (rand_a[1]) begin
      conditional_d = ~rand_b[3:0];
    end else begin
      conditional_d = rand_b[7:4];
    end
  end
  `signal(CONDITONAL_D, conditional_d);

  logic [3:0] conditional_e;
  always_comb begin
    conditional_e = 4'd0;
    if (rand_a[0]) begin
      conditional_e = rand_b[3:0];
    end else begin
      if (rand_a[1]) begin
        conditional_e = rand_b[3:0];
      end else begin
        conditional_e = rand_b[7:4];
      end
      conditional_e = ~conditional_e;
    end
  end
  `signal(CONDITONAL_E, conditional_e);

  logic condigional_f;
  always_comb begin
    if (rand_b[0]) begin
      condigional_f = 1'h1;
      if (rand_b[1]) begin
        condigional_f = rand_a[0];
      end
    end else begin
      condigional_f = 1'b0;
    end
  end
  `signal(CONDITONAL_F, condigional_f);

  logic [7:0] partial_conditional_a;
  always_comb begin
    partial_conditional_a[1:0] = 2'd0;
    if (rand_a[0]) begin
      partial_conditional_a[0] = rand_b[0];
    end else begin
      partial_conditional_a[1] = rand_b[1];
    end
    partial_conditional_a[4:3] = rand_b[4:3];
  end
  `signal(PARTIAL_CONDITONAL_A, partial_conditional_a);

  logic [3:0] partial_conditional_b;
  always_comb begin
    partial_conditional_b[1:0] = 2'd0;
    if (rand_a[0]) begin
      partial_conditional_b[0] = rand_b[0];
    end
    if (rand_a[1]) begin
      partial_conditional_b[1] = rand_b[1];
    end
  end
  `signal(PARTIAL_CONDITONAL_B, partial_conditional_b);

  logic [3:0] becomes_full;
  always_comb begin
    becomes_full[2:0] = rand_a[2:0];
    becomes_full[3] = ~rand_a[3];
    if (rand_b[0]) begin
      becomes_full = ~becomes_full;
    end
  end
  `signal(BECOMES_FULL, becomes_full);

  // verilator lint_off LATCH
  logic [3:0] latch_a;
  logic [3:0] latch_b;
  always_comb begin // nosynth
    if (rand_b[0]) begin
      latch_a[3:1] = ~rand_a[3:1];
    end
    latch_b = latch_a;
  end
  assign latch_a[0] = rand_a[0];
  `signal(LATCH, latch_b);
  // verilator lint_on LATCH

  // verilator lint_off MULTIDRIVEN
  logic static_temporary_a;
  logic static_temporary_b;
  logic static_temporary_tmp;
  always_comb begin // revert
    static_temporary_tmp = rand_a[0];
    static_temporary_a = ~static_temporary_tmp;
  end
  always_comb begin // revert
    static_temporary_tmp = static_temporary_a;
    static_temporary_b = ~static_temporary_tmp;
  end
  // verilator lint_on MULTIDRIVEN
  `signal(STATIC_TEMPORARY, {static_temporary_tmp, static_temporary_b, static_temporary_a, rand_a[0]});

  logic [2:0] partial_temporary_a;
  logic [2:0] partial_temporary_tmp;
  always_comb begin
    partial_temporary_tmp[2] = rand_a[3];
    partial_temporary_tmp[1] = rand_a[2];
    partial_temporary_tmp[0] = rand_a[1];
    partial_temporary_a = partial_temporary_tmp;
  end
  `signal(PARTIAL_TEMPORARY, partial_temporary_a);
endmodule
