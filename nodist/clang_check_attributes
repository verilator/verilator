#!/usr/bin/env python3
# pylint: disable=C0114,C0115,C0116,C0209
#
# Copyright 2022 by Wilson Snyder. Verilator is free software; you
# can redistribute it and/or modify it under the terms of either the GNU Lesser
# General Public License Version 3 or the Apache License 2.0.
# SPDX-License-Identifier: LGPL-3.0-only OR Apache-2.0
#
# Based on the work of (Guillaume "Vermeille" Sanchez)[https://github.com/Vermeille/clang-callgraph]
# licensed under Apache 2.0
import argparse
import sys
import os
from pathlib import Path
from pprint import pprint
from clang.cindex import CursorKind, Index


# https://stackoverflow.com/a/74205044
class FixSizedDict(dict):

    def __init__(self, *args, maxlen=0, **kwargs):
        self._maxlen = maxlen
        super().__init__(*args, **kwargs)

    def __setitem__(self, key, value):
        dict.__setitem__(self, key, value)
        if self._maxlen > 0:
            if len(self) > self._maxlen:
                self.pop(next(iter(self)))


# by definition constructor is MT safe,
# but functions that constructor call are not!
MT_SAFE_DEFINITION_KINDS = [CursorKind.CONSTRUCTOR]
VERILATOR_ROOT = Path(__file__).parent.parent.resolve()
IGNORE_FILES_LIST = [
    # Dont process test files
    "_test.cpp",
    # Dont process Verilator coverage files
    "Vlc",
    # We want to use V3Const after astgen
    "V3Const.cpp",
    # Skip SystemC files
    "_sc",
    # Skip parser files
    ".yy.cpp"
]

index = Index.create()
# Cache of files already turned into translate unit
# this speeds up checking when used function is from another
# translation unit, but it increases memory consumption.
# Limit max cache size to 20, to make sure we won't run OOM
# in github actions
translate_units = FixSizedDict(maxlen=20)
# Already printed nodes in current function.
# This prevents infinite loops due to recursion
printed = []
# Nodes that were marked as MT_SAFE, but are calling
# function that isn't marked with this attribute
unsafe_calls = []


def get_diag_info(diag):
    return {
        'severity': diag.severity,
        'location': diag.location,
        'spelling': diag.spelling,
        'ranges': list(diag.ranges),
        'fixits': list(diag.fixits)
    }


def get_translate_unit(file, cfg):
    file = str(file)
    try:
        translate_unit = translate_units[file]
    except KeyError:
        translate_unit = index.parse(file, cfg.clang_args)
        if not translate_unit:
            print(f"%Error: unable to load translate unit from file: {file}")
            sys.exit(1)
        for diag in translate_unit.diagnostics:
            if diag.severity in [diag.Error, diag.Fatal]:
                pprint(('diags',
                        list(map(get_diag_info, translate_unit.diagnostics))))
                sys.exit(1)
        translate_units[file] = translate_unit
    return translate_unit


def print_node(node, level):
    if fully_qualified_pretty(node) not in printed:
        annotations = get_annotations(node)
        if node.kind in MT_SAFE_DEFINITION_KINDS:
            annotations.append("MT_SAFE_DEFINITION")
        filepath = Path(str(node.location.file)).resolve()
        try:
            filepath_relative = filepath.relative_to(VERILATOR_ROOT)
            print('%-50s %-40s %s %-100s' %
                  (f"{filepath_relative}:{node.extent.start.line}:",
                   annotations, ' ' * level, fully_qualified_pretty(node)))
        except ValueError:
            print(
                f"%Error: unsafe call to function outside verilator: {filepath}: {fully_qualified_pretty(node)}"
            )
            sys.exit(1)
        printed.append(fully_qualified_pretty(node))


def get_annotations(node):
    return [
        c.displayname for c in node.get_children()
        if c.kind == CursorKind.ANNOTATE_ATTR
    ]


def fully_qualified(cursor):
    if cursor is None:
        return ''
    if cursor.kind == CursorKind.TRANSLATION_UNIT:
        return ''

    res = fully_qualified(cursor.semantic_parent)
    if res != '':
        return res + '::' + cursor.spelling
    return cursor.spelling


def fully_qualified_pretty(cursor):
    if cursor is None:
        return ''
    if cursor.kind == CursorKind.TRANSLATION_UNIT:
        return ''

    res = fully_qualified(cursor.semantic_parent)
    if res != '':
        return res + '::' + cursor.displayname
    return cursor.displayname


def is_excluded(node, cfg):
    xpaths = cfg.exclude_paths
    xprefs = cfg.exclude_prefixes
    if not node.extent.start.file:
        return False

    for xpath in xpaths:
        if str(Path(node.extent.start.file.name).resolve()).startswith(xpath):
            return True

    fqp = fully_qualified_pretty(node)

    for xpref in xprefs:
        if fqp.startswith(xpref):
            return True

    return False


def get_call_expr(node):
    call_expr = []
    for cursor in node.get_children():
        call_expr.extend(get_call_expr(cursor))
    if node.kind == CursorKind.CALL_EXPR:
        call_expr.append(node)
    return call_expr


def find_usr(file, usr, cfg):
    translate_unit = get_translate_unit(file, cfg)
    for cursor in translate_unit.cursor.get_children():
        if cursor.get_usr() == usr:
            return cursor
    return None


def check_attributes(cursor, search_attributes):
    if cursor.kind in MT_SAFE_DEFINITION_KINDS:
        return True
    for attribute in search_attributes:
        if attribute in get_annotations(cursor):
            return True
    return False


def find_funcs(node, cfg, search_attributes=None, level=1, verbose=False):
    funcs = get_call_expr(node)
    for func in funcs:
        if not func.referenced:
            continue
        if is_excluded(func.referenced, cfg):
            continue
        call = func.referenced
        # Don't recurse into already printed nodes
        # it some cases in increases printing nodes by a lot
        if fully_qualified_pretty(call) in printed:
            continue
        if str(call.location.file).endswith(".h"):
            cpp_file = str(call.location.file).replace(".h", ".cpp")
            if os.path.exists(cpp_file):
                tu_call = find_usr(cpp_file, call.get_usr(), cfg)
                if tu_call is not None:
                    call = tu_call

        if call is not None:
            if verbose:
                print_node(call, level)
            else:
                if fully_qualified_pretty(call) not in printed:
                    printed.append(fully_qualified_pretty(call))

                if not check_attributes(call, search_attributes):
                    return False
            if call.kind in [
                    CursorKind.CXX_METHOD, CursorKind.CONSTRUCTOR,
                    CursorKind.FUNCTION_DECL
            ]:
                if not find_funcs(call, cfg, search_attributes, level + 1,
                                  verbose) and not verbose:
                    return False
    return True


def get_info(node, cfg):
    if node.kind == CursorKind.CXX_METHOD:
        annotations = get_annotations(node)
        if "MT_SAFE" in annotations:
            if not find_funcs(node, cfg, ["MT_SAFE", "PURE"]):
                unsafe_calls.append(node)
        if "PURE" in annotations:
            if not find_funcs(node, cfg, ["PURE"]):
                unsafe_calls.append(node)
        if "MT_START" in annotations:
            if not find_funcs(node, cfg, ["MT_SAFE", "PURE"]):
                unsafe_calls.append(node)
    for cursor in node.get_children():
        get_info(cursor, cfg)


def get_files(filename):
    files = list(Path(filename).rglob('*.cpp'))
    for ignore in IGNORE_FILES_LIST:
        files = list(f for f in files if ignore not in str(f))

    # Make sure list is unique
    files = list(dict.fromkeys(files))
    # Make filepaths absolute
    files = [f.absolute() for f in files]
    return files


def parse_exclude(exclude_string):
    return exclude_string.split(',')


def main():
    parser = argparse.ArgumentParser(
        allow_abbrev=False,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description="""Check function annotations for correctness""",
        epilog=
        """Copyright 2022 by Wilson Snyder. Verilator is free software; you
    can redistribute it and/or modify it under the terms of either the GNU
    Lesser General Public License Version 3 or the Apache License 2.0.

    SPDX-License-Identifier: LGPL-3.0-only OR Apache-2.0""")

    parser.add_argument('-x',
                        dest='exclude_prefixes',
                        type=parse_exclude,
                        help='comma separated list of excluded prefixes')
    parser.add_argument('-p',
                        dest='exclude_paths',
                        type=parse_exclude,
                        nargs="?",
                        help='comma separated list of excluded paths')
    parser.add_argument('-I',
                        dest='clang_args',
                        action='append',
                        help='extra clang arguments')
    parser.add_argument('input_folders',
                        nargs='*',
                        help='list of input paths for .cpp files')

    cfg, unknowns = parser.parse_known_args()
    # Add -I stripped by argparser to clang_args
    cfg.clang_args = [f"-I{clang_arg}" for clang_arg in cfg.clang_args]
    if cfg.exclude_paths is None:
        cfg.exclude_paths = ["/usr"]
    # if option starts with dash, assume it is clang arg
    for unknown in unknowns:
        if unknown.startswith('-'):
            cfg.clang_args.append(unknown)

    files = []
    for folder in cfg.input_folders:
        files.extend(get_files(folder))
    files.sort()
    for file in files:
        translate_unit = get_translate_unit(file, cfg)
        get_info(translate_unit.cursor, cfg)

    for call in unsafe_calls:
        printed.clear()
        print(f"::group::{fully_qualified_pretty(call)}")
        print_node(call, 0)
        find_funcs(call, cfg, search_attributes=None, level=1, verbose=True)
        print("::endgroup::")

    print(
        f"Number of functions marked as MT_SAFE calling unsafe functions: {len(unsafe_calls)}"
    )


if __name__ == '__main__':
    main()
